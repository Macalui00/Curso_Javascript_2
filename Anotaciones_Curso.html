<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
    
        <title>Anotaciones del Curso Javascript</title>

        <!-- Google Fonts -->
        <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,500,700|Open+Sans:300,300i,400,400i,700,700i" rel="stylesheet">

    </head>

    <body>
        <h1>Anotaciones del curso de Javascript</h1>

        <p>El curso es el siguiente: "The Modern JavaScript Bootcamp Course (2020)" de Udemy Business</p>
            
        <h2>NaN o Not a Number</h2>
        <p> Hay una cosa importante que hay que saber de los numeros en JavaScript, que es el NaN, que es un valor especial en Javascript.
            Es un valor especial en Javascript y SE CONSIDERA UN NUMERO. ES UN VALOR NUMERICO QUE REPRESENTA ALGO QUE NO ES UN NUMERO.
            Hay diferentes formas en las que tu puedes caer en un NaN, dos casos simples:
                - 0/0 //NaN
                - 1 + NaN //NaN
            Tenes que capitalizarlo correctamente para que se tome como el valor Not a Number.
            Tenemos otros dos valores que son: Infinity, que se genera haciendo algo como 1/0. Javascript solo tiene una manera de representar 
            un valor de infinidad. No hay manera de almacenarlo como un numero que uno pueda ver. Por lo que tenemos un valor especial llamado
            Infinity. Hay tambien un -Infinity (infinito negativo): -1/0.
            Tambien tenemos 0 y -0.
            NaN no necesariamente significa que algo anda mal. A veces podes estar codeando algo que espera un NaN o que puede ser una posibilidad.
            Por lo que, no es necesariamente un error pero significa que esto no es un estandar matematico o que javascript va a tener una
            complicacion, representando este numero o este valor como un verdadero valor numerico.  
        </p>
        <h2>Variables y Let</h2>
        <p> Variables son como frascos etiquetados para valores en JavaScript.
            Podemos almacenar un valor y darle un nombre, entonces, podemos:
                - volver a llamarlos
                - usarlos
                - o cambiarlos luego.
            La sintaxis basica que veremos primero es usar la palabra clave llamada Let:
                let algunNombre = valor;
            De hecho, hay dos manerad diferentes en las que podemos crear variables en JavaScript:
                - let: en cualquier punto del código puedo volver a llamarla.
                - const
            Unas cosas que debes saber de las variables:
                - Puedes llamarlas practicamente de cualquier manera, ejemplo:
                    let let = 10; Javascript estara muy confundido porque let es una palabra reservada,
                    es una palabra clave en el lenguaje de JavaScript, por lo que javascript piens que
                    estamos intentando hacer otra variable ahi y como se puede ver, si prueba esa sentencia
                    estará desabilitado.
                    Otro ejemplo de esto es la palabra document, que es un objeto en javascript, por lo que
                    si uno intenta hacer una variable con ese nombre, no te dejará.

            Camelcase: Cuando tengo mas de una palabra en el nombre de la variable, se capitalizan las
            primeras letras de las palabras, excepto de la primera palabra.

            Si intentas redeclarar una variable que ya has hecho, no te va a dejar.
        </p>
        <h2>Const: constantes</h2>
        <p>const nombreVar = valor;
            Hay una gran diferencia con let, no podes cambiar el valor de la variable.
        </p>
        <h2>Algunos metodos de arrays interesantes</h2>
        <p>Estos son:
                - Concat: para concatenar arrays
                - Includes: buscar un valor dentro del arrays
                - IndexOF: igual que el str.indexOf. para saber cual es su index?
                - Join: crear un string a partir de un array.
                - Reverse: crea un array inverso al que tenias.
                - Slice: copia una porcion del array. 
                - Splice: remueve o reemplaza elementos. 
                - Sort: ordena un array. 
        </p>
        <h2>Nested Arrays</h2>
        <p>Tener arrays dentro de arrays.
            UN ejemplo del uso de esto, puede ser un tateti:
            const board = [['0',null, '0'],
                        [null,'X', '0'],
                        ['X', '0', null]]
        </p>
        <h2>Scope y Function Scope</h2>
        <p> Es como la visibilidad de una variable: el lugar donde una variable es definida indica en
            donde se puede acceder a esa variable.
            Hay multiples piezas/formas de como se comporta el scope en JavaScript.
            El primer tipo de Scope es el Function Scope: me indica que las variables dentro de la funcion,
            solo pueden ser accedidas dentro de esa misma funcion. No puedo acceder a una variable que esta
            dentro de esa funcion. Esto entre otras cosa me permite, porder tener varias variables llamadas
            de la misma manera dentro de funciones diferentes, e incluso tener una variable dentro de la
            funcion y otra fuera de cualquier funcion y que se llamen igual
        </p>
        <h2>Scope y Block Scope</h2>
        <p>
            Otro tipo de Scope, que se llama Block Scope, y no necesariamente tiene que ver con funciones, o,
            al menos no directamente, pero se ha mencionado al principio de la seccion, cubriremos alguna 
            funcion adjyacente contenida.
            Veamos un ejemplo:
            if (true){
                let animal = 'eel';
            }
            console.log(animal);
            Nos dará error porque la variable animal esta dentro del bloque condicional if. Los bloques en
            javascript estan delimitados por {}. Hay que tener en cuenta que esto es muy diferente a lo que
            sería un objeto literal o object literal que es tambien entre {}:
            {
                a: 1,
                b: 2,
                c: b
            }
            esto de arriba es un objeto, lo del bloque if si es realmente un bloque. Lo mismo irá si tenemos
            ejemplo, un while loop, for loop.
            De manera que:
            if (true){
                let animal = 'eel';
                console.lo(animal); //Acá si tengo acceso a la variable.
            }
            console.log(animal); //Acá no tengo acceso a la variable.
            
            Esto mismo ocurrirá si uso const en vez de let:
            
            if (true){
                const animal = 'eel';
                console.lo(animal); //Acá si tengo acceso a la variable.
            }
            console.log(animal); //Acá no tengo acceso a la variable.

            Pero que ocurrirá si utilizo var en vez de const y let?:
            if (true){
                var animal = 'eel';
                console.lo(animal); //Acá si tengo acceso a la variable.
            }
            console.log(animal); //Acá también tengo acceso a la variable.

            Esto nos indica que let y const tienen un reglas de scoping
            diferentes a var. No hay block scope para var. Esto puede llegar
            a ser problematico y es diferente a como otros lenguajes de
            programacion funcionan, esto es porqeu let y const son propuestos
            a parte de otras razones.
            Hay otras distinciones entre el const y el let pero tambien por 
            razones de scoping, y es por esto que puede llegar a ser
            problematico.
            Entonces, porque puede llegar a ser problematico tener declarada
            una variable en el bloque y tener acceso a ella afuera?
            Hay multiples razones, pero para ilustrar un simple problema con
            el que solemos encontrarnos: 
            
            var i = 10;
            let animal = ['grizzly bear', 'panda bear', 'spectacled bear']
            for(var i = 0; i < animals.length; i++){
                console.log(i, animals[i])
            }

            Y aquí esta el problema, si imprimo por pantalla, fuera del loop i,
            sigue existiendo:

            console.log(i);

            Entonces, seguimos teniendo acceso al i, y esto puede llegar a ser problematico,
            si por ejemplo, fuera del loop tuviera otra variable llamada i, por lo que el
            loop me puede cambiar el valor de la variable i de fuera del loop.

            En cambio, si hago esto con let:
            var i = 10; //podemos usar tambien let en este caso.
            let animal = ['grizzly bear', 'panda bear', 'spectacled bear']
            for(let i = 0; i < animals.length; i++){
                console.log(i, animals[i])
            }

            console.log(i); //el i que me retornará es el 10

            si dos variables existen en diferentes scopes no van a interferir entre ellas ni
            van a generar conflictos.
            Con let y const no podemos el mismo identificador de variabe dos veces, con var si.

            Una funcion que tambien incluye un bloque en el:
            function dobleArray(arr){
                const resultado = [];
                for (let num of arr){
                    let doble = num * 2;
                    resultado.push(doble);
                }
                console.log(doble); //No tenemos acceso a la variable doble.
                return resultado; //podemos retornar el resultado porque la variable fue definida por fuera del bloque.
            }
        </p>
        <h2>Scope y Lexical Scope</h2>
        <p> Cuando tenemos nested functions que es algo que a veces hacemos. 
            Si utiliza cosas como react, utilizará muy seguido nested functions (funciones dentro de otras). 
            function outer(){ //no tengo acceso al afuera de esta funcion
                let hero = "Black Panther";

                function inner(){ //pero si estoy en una funcion interna del nested sigo teniendo acceso al hero:
                    let cryForHelp = '${hero}, please save me!'
                    console.log(cryForHelp);
                }
            }

            function outer(){ //no tengo acceso al afuera de esta funcion
                let movie = "Black Panther";

                function inner(){ //pero si estoy en una funcion interna del nested sigo teniendo acceso al hero:
                console.log(movie.toUpperCase());
                }
                //Si declaro inner dentro de la funcion outer
                inner();
            }

            Pero que pasa si llamo la funcion inner por afuera de la funcion outer:
            No tengo acceso a ella.

            Por ende, a la funcion inner tengo acceso solo dentro de la funcion outer pero no fuera de ella.
            Entonces, lexical scope se refiere al hecho de que nested functions la funcion outer y la funcion inner estan muy conectadas.
            
            function outer(){ //no tengo acceso al afuera de esta funcion
                let movie = "Black Panther";

                function inner(){
                    let movie = "The Shining"
                console.log(movie.toUpperCase()); //THE SHINING
                }
                
                inner();
            }
        </p>

        <h2>Expresiones de Funciones</h2>
        <p>
            Una forma de escribir las funciones:
            function nombreFuncion(Parámetros){
                //return algo; //Puede o no retornar algo.
            }
            Pero vamos a ver una sintaxis completamente diferente:
            Se ve bastante similar pero es completamente diferente, que se llama function expression. 
            Empiezan con una variable, la funcion en si no tiene un nombre, y la almaceno en la variable.
            Puedo almacenar funciones en variables porque LAS FUNCIONES SON OBJETOS EN JAVASCRIPT.
            Para llamarla, referencio el nombre de la variable y le paso el argumento de la funcion.
            Ejemplo:

            const square = function (num){
                return num * num;
            }
            square(7); //49

            Veamos otro ejemplo:
            
            function add(x,y){
                return x + y;
            }

            La funcion ANONIMA equivalente es la siguiente, que tiene el inconveniente de que asi escrita tal cual,
            no tengo manera de llamarla.

            function (x, y){
                return x + y;
            }

            Por lo que tengo que almacenarla en algun lado, o la uso en funciones que tienen funciones como parametros
            o funciones que retornan funciones. 

            const sum = function (x,y){
                return x+y;
            }

            Podemos inspeccionarlas:
            console.dir(sum)
            console.dir(add)

            la siguiente sigue siendo una function expression pero se trata de named function expression y la otra era una
            anonimous function expression.
            const product = function multiply(x,y){
                return x*y;
            }

            si llamo:
            product(3,5) //funciona 
            
            pero si llamo:
            multiply(3,5) //no funciona. 
        </p>

        <h2>Funciones de orden superior</h2>
        <p>
            No solo podemos almacenar funciones en variables, sino tambien en arrays. 

            function add(x,y){
                return x + y;
            }

            const subtract = function(x,y){
                return x - y;
            }

            function multiply(x,y){
                return x * y;
            }

            const divide = function (x,y){
                return x / y;
            }

            const operations = [add, substract, multiply, divide];

            en consola:
            operations[1]

            operations[1](100,4)
            operations[2](100,4)

            for (let func of operations){
                let result = func(30,5);
                console.log(result);
            }

            Tambien lo podemos almacenar en un objeto:
            const thing = {
                doSomething: multiply
            }

            thing.doSomething(50,2);
        </p>

        <h2>Callbacks functions </h2>
        <p>
            Son funciones pasadas en otras funciones como argumentos, que es luego invocada dentro de la outer function.
            function callTwice(func){
                func();
                func();
            }
            function laugh(){
                console.log("HAHAHAHAHAHAHAHAHAHA");
            }
            callTwice(laugh) //Pasando la funcion como argumento, esta funcion pasada como argumento es a lo que llamamos callback function
        
            Estas funciones son extremadamente comunes en javascript.
            En javascript hay un metodo llamado setTimeout() el cual se ejecutara un determinado bloque de código o una funcion de codigo
            despues de un determinado numero de milisegundos o segundos que nosotros le pasemos en numeros de milisegundos como: 5000.. Pero,
            el primer elemento que le debemos pasar es una funcion, una funcion para correr y despues cuanto tiempo hay que esperar antes de
            que se ejecute:
            setTimeout(func, 5000);

            Vamos a definir una funcion:
            function grumpus(){
                alert("GAAH GO AWAY!");
            }
            setTimeout(grumpus, 5000);

            Podemos usar el setTimeout con una funcion anonima:
            setTimeout(function(){ //Lo hago de esta manera porque no es una funcion que quiera reutilizar.
                alert("Welcome!");
            }, 5000);

            Vamos a agregar un boton a la pantalla:
        </p>

        <button>Don't click me!</button>
        <p> 
            El script de javascript hay que colocarlo siepre abajo de esto para poder funcionar.
        </p>

        <h2>Hoisting</h2>
        <p>
            Que pasa si hago:
            var animal = 'Tapir';
            console.log(animal);

            Pero ahora que pasa si invierto el orden:
            console.log(animal); //Obtengo undefined
            var animal = 'Tapir';

            Esto era lo que esperaba o quizas no esperaba que sucediera pero que pasa si hago lo siguiente:
            console.log(animal); //No existe. ERROR! ANIMAL NO ESTA DECLARADO. 
            //var animal = 'Tapir';

            ESTE COMPORTAMIENTO EXTRAÑO ES HOISTING:
            console.log(animal); 
            var animal = 'Tapir';
            javascript lee este codigo y lo que hace es reorganizar el codigo:

            var animal;
            console.log(animal);
            animal = 'Tapir';
            console.log(animal);

            Entonces esto es con var, ahora comparemos con let y const:
            let shrimp = "Harlequin shrimp";
            console.log(shrimp);

            Ahora que pasa si invertimos el orden:
            console.log(shrimp); //Error de referencia, no podemos acceder a shrimp antes de su inicializacion.
            let shrimp = "Harlequin shrimp";

            Entonces las declaraciones de variables con let no tienen hoisting como si lo tienen las declaraciones con var.
            Y esa es una de las razones por las que usamos let. 

            Y haciendo lo mismo con const:
            console.log(shrimp); //Error de referencia, no podemos acceder a shrimp antes de su inicializacion.
            let shrimp = "Harlequin shrimp";
            obtengo el mismo resultado. 
        </p>

        <script src="Anotaciones_Curso_Javascript.js"></script> 
    
    </body>

</html>